\chapter{Конструкторская часть}

\section{Требования к реализации}

К программе предъявлены ряд функциональных требований: входные данные – последовательность целых чисел (0, 1, 2), выходные данные – количество единиц в последовательности до первого вхождения числа 2.

\vspace{10pt}

К программе предъявлены ряд требований:
\begin{itemize}[label=---]
	\item наличие интерфейса для выбора действий;
	\item реализация рекурсивного алгоритма подсчёта единиц в последовательности;
	\item реализация нерекурсивного алгоритма подсчёта единиц в последовательности;
	\item наличие функциональности замера процессорного времени выполнения алгоритмов;
	\item поддержка ввода последовательности чисел с проверкой корректности данных.
\end{itemize}

\vspace{10pt}

Программа работает в трёх режимах: 
\begin{itemize}[label=---]
	\item выполнение рекурсивного алгоритма;
	\item выполнение нерекурсивного алгоритма;
	\item замер процессорного времени выполнения алгоритмов.
\end{itemize}

При первом и втором режимах на вход поступает последовательность чисел (0, 1), завершающаяся числом 2, на выход – количество единиц в последовательности до первого вхождения числа 2.

При третьем режиме работы на вход поступают минимальный размер последовательности, максимальный размер, шаг изменения размера и число итераций k (k $\ge$ 100), на выход — результаты замера времени в виде таблицы, где каждая точка получается делением времени выполнения k идентичных расчётов на k.

\section {Разработка алгоритмов}

Раздел содержит блок-схемы, описывающие следующие алгоритмы: рекурсивный алгоритм подсчёта единиц в последовательности, нерекурсивный алгоритм подсчёта единиц в последовательности.

\begin{figure}[h!]\label{iterative} 
	\center{\includegraphics[scale=0.9]{./images/iterative.png}} 
	\caption{Схема нерекурсивного алгоритма}
\end{figure}\clearpage

\begin{figure}[h!]\label{recursive} 
	\center{\includegraphics[scale=0.7]{./images/recursive.png}} 
	\caption{Схема рекурсивного алгоритма}
\end{figure}\clearpage

\section {Модель вычислений}
Для проведения оценки трудоёмкости была введена модель вычислений.

\begin{enumerate} 
	\item[1) ] трудоёмкость базовых операций:
	\begin{itemize} 
		\item равна 1 для: =, !=, ==, <, >, <=, >=, |, ||, \&, \&\&, |=, \&=, +, ++,  -, --,  +=, -=, [], $<<$, $>>$;
		\item равна 2 для: *, /, *=, /=, \%, \%=.
	\end{itemize}
	\item[2) ] трудоёмкость условного оператора:
	\[
	f_{if} = f_{\text{условия}} + 
	\begin{cases}
		min(f_1, f_2), & \text{л. с.}\\
		max(f_1, f_2), & \text{х. с.}
	\end{cases}
	\]
	\item[3) ] трудоёмкость цикла:
	\[
	f_{for} = f_{\text{инициализации}} + f_{\text{сравнения}} + M_{\text{итераций}} \cdot (f_{\text{тела}} + f_{\text{инкремента}} + f_{\text{сравнения}})
	\]
\end{enumerate}

\section {Трудоёмкость и затраты памяти алгоритмов}

В этом разделе приведены оценки трудоёмкостей и затрат памяти алгоритмов согласно реализациям.

\subsection{Оценка трудоемкости алгоритмов}

\subsubsection{Нерекурсивный алгоритм}

Пусть длина последовательности n. В худшем случае в последовательности только единицы.
\begin{enumerate}
	\item инициализация переменной \texttt{count}: $f_{init} = 1$;
	\item цикл по элементам: $f_{loop} = 2 + n \cdot (2 + f_{body})$;
	\item тело цикла: $f_{body} = f_{2\_check} + f_{1\_check}$;
	\item проверка на равенство двойке: $f_{2\_check} = 1$;
	\item проверка на равенство единице: $f_{1\_check} = 1 + 1$;
	\item возврат результат: $f_{return} = 1$.
\end{enumerate}

Результирующее выражение:
$$f_{iterative} = f_{init}  + f_{loop} + f_{return} = 1 + 2 + n \cdot (2 + 1 + 2) + 1 = 4 + 5 \cdot n \approx O(n)$$

\subsubsection{Рекурсивный алгоритм}
Пусть длина последовательности n. В худшем случае в последовательности только единицы, то есть будет n вызовов.

\begin{enumerate}
	\item проверка на пустоту: $f_{is\_empty} = 1$;
	\item проверка первого элемента: $f_{first} = 1 + 1$;
	\item рекурсия: $f_{recursive\_case} = 2 + 1 + f_{call}$;
	\item вызов функции: $f_{call} = 2 \cdot (1 + 1 + 1 + 1) = 8$.
\end{enumerate}

Результирующее выражение:
$f_{recursive} = n \cdot (1 + 2 + 2 + 1 + 8) + 1 + 1 = 14n + 2 \approx O(n)$

\subsection{Оценка затрат памяти алгоритмов}

\subsubsection{Нерекурсивный алгоритм}

Затраты памяти нерекурсивного алгоритма:
\begin{itemize}
	\item результат: $O(1)$ – одна целочисленная переменная;
	\item локальные переменные: $O(1)$ – переменные count, x, итератор цикла;
	\item параметры функции: $O(1)$ – ссылка на срез.
\end{itemize}

Общие затраты памяти: $O(1)$

\subsubsection{Рекурсивный алгоритм}

Затраты памяти рекурсивного алгоритма:
\begin{itemize}
	\item результат: $O(1)$ – одно целое число;
	\item стек вызовов: O(n), где n – длина среза до первого элемента 2;
	\item память на один вызов функции:
	\begin{itemize}
		\item адрес возврата: 8 байт;
		\item сохранение регистров: 16 байт;
		\item параметры функции: 16 байт;
		\item локальные переменные: 8 байт;
		\item служебная информация: 8 байт.
	\end{itemize}
	Итого на один вызов 56 байт
\end{itemize}

Общие затраты памяти: $O(n)$ Высота дерева рекурсивных вызовов: n. Максимальный объём
памяти стека: $56 \cdot n$ байт.

\section*{Вывод}

В данном разделе были разработаны и проанализированы два алгоритма подсчёта единиц в последовательности: рекурсивный и нерекурсивный. Для каждого из них представлены блок-схемы, описывающие логику работы. На основе введённой модели вычислений проведена оценка трудоёмкости алгоритмов, которая показала, что оба алгоритма имеют линейную временную сложность $O(n)$. Оценка затрат памяти выявила, что нерекурсивный алгоритм требует $O(1)$ памяти, в то время как рекурсивный, вследствие использования стека вызовов, – $O(n)$. Таким образом, с точки зрения эффективности использования памяти нерекурсивный алгоритм является более предпочтительным.

\clearpage
