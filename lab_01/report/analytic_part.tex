\chapter{Аналитическая часть}

\section {Понятие матрицы}
\textbf{Матрица} – таблица чисел $a_{ik}$, состоящая из $m$ строк и $n$ столбцов, вида
\begin{equation}
	\begin{pmatrix}
		a_{11} & a_{12} & \ldots & a_{1m}\\
		a_{21} & a_{22} & \ldots & a_{2m}\\
		\vdots & \vdots & \ddots & \vdots\\
		a_{n1} & a_{n2} & \ldots & a_{nm}
	\end{pmatrix}
\end{equation}

$a_{ij}$ – \textit{элемент матрицы} в $i$ строке и $j$ столбце.

\vspace{10pt}
\textbf{Операции над матрицами:}

\begin{enumerate}
	\item \textbf{сложение матриц:} Матрицы одинакового размера складываются поэлементно~\cite{verbickiy2018};
	\item \textbf{умножение матрицы на число:} Каждый элемент матрицы умножается на скаляр~\cite{verbickiy2018};
	\item \textbf{умножение матриц:} Произведение матриц $A$ размером $m \times n$ и $B$ размером $n \times k$ определяется как матрица $C$ размером $m \times k$. В общем случае умножение $AB \neq BA$ (не коммутативно)~\cite{verbickiy2018}.
\end{enumerate}

\vspace{10pt}
\textbf{Виды матриц:}

\begin{enumerate}
	\item \textbf{квадратная матрица:} матрица, у которой количество строк равно количеству столбцов ($m = n$)~\cite{verbickiy2018}
	
	\item \textbf{единичная матрица:} квадратная матрица $E$, у которой элементы на главной диагонали равны 1, а остальные равны 0~\cite{verbickiy2018}:
	\begin{equation}
		e_{ij} = \begin{cases} 1, & \text{если } i = j \\ 0, & \text{если } i \neq j \end{cases}
	\end{equation}
	
	\item \textbf{диагональная матрица:} квадратная матрица, у которой все элементы вне главной диагонали равны нулю~\cite{verbickiy2018}:
	\begin{equation}
		d_{ij} = \begin{cases} d_{ii}, & \text{если } i = j \\ 0, & \text{если } i \neq j \end{cases}
	\end{equation}
	
	\item \textbf{нулевая матрица:} матрица, все элементы которой равны нулю~\cite{verbickiy2018}:
	\begin{equation}
		0_{ij} = 0 \text{ для всех } i, j
	\end{equation}
\end{enumerate}

\section{Классический алгоритм умножения матриц}

Даны две матрицы:

\begin{equation}
	A = 
	\begin{pmatrix}
		a_{11} & a_{12} & \ldots & a_{1m}\\
		a_{21} & a_{22} & \ldots & a_{2m}\\
		\vdots & \vdots & \ddots & \vdots\\
		a_{n1} & a_{n2} & \ldots & a_{nm}
	\end{pmatrix},  
	B = 
	\begin{pmatrix}
		b_{11} & b_{12} & \ldots & b_{1t}\\
		b_{21} & b_{22} & \ldots & b_{2t}\\
		\vdots & \vdots & \ddots & \vdots\\
		b_{m1} & b_{m2} & \ldots & b_{mt}
	\end{pmatrix}
\end{equation}

Результатом их произведения является матрица:

\begin{equation}
	C = 
	\begin{pmatrix}
		c_{11} & c_{12} & \ldots & c_{1t}\\
		c_{21} & c_{22} & \ldots & c_{2t}\\
		\vdots & \vdots & \ddots & \vdots\\
		c_{n1} & c_{n2} & \ldots & c_{nt}
	\end{pmatrix}
\end{equation}

\vspace{10pt}
При умножении матрицы $A_{n \times m}$ на матрицу $B_{m \times t}$ получается матрица $C_{n \times t}$, каждый элемент которой вычисляется по формуле~\cite{cormen2009}:

\begin{equation}
	c_{ij} = a_{i1}b_{1j} + a_{i2}b_{2j} + \dots + a_{im}b_{mj} = \sum_{k=1}^{m} a_{ik}b_{kj}
\end{equation}

Временная сложность классического алгоритма умножения матриц составляет $O(n^3)$~\cite{cormen2009}.

\section{Алгоритм Винограда умножения матриц}

Алгоритм Винограда основан на оптимизации вычисления скалярного произведения векторов~\cite{winograd1968}. Основная идея заключается в предварительной обработке данных, которая позволяет сократить количество операций умножения.

Даны два вектора $U = (u_1, u_2, u_3, u_4)$ и $W = (w_1, w_2, w_3, w_4)$. Их скалярное произведение можно записать как:
\begin{equation}
	U \cdot W = u_1w_1 + u_2w_2 + u_3w_3 + u_4w_4
\end{equation}

Это выражение можно преобразовать к виду~\cite{winograd1968}:
\begin{equation}
	U \cdot W = (u_1 + w_2)(u_2 + w_1) + (u_3 + w_4)(u_4 + w_3) - u_1u_2 - u_3u_4 - w_1w_2 - w_3w_4
\end{equation}

Хотя количество операций увеличилось, второе и третье слагаемые можно вычислить заранее для каждой строки и столбца исходных матриц. Это позволяет выполнять только два умножения и несколько сложений для каждого элемента результирующей матрицы.

Для матриц $A_{n \times m}$ и $B_{m \times k}$ алгоритм работает следующим образом:

\begin{enumerate}
	\item вычисляются вспомогательные векторы:
	\begin{equation}
		MulH_i = \sum_{j=1}^{m/2} a_{i,2j-1} \cdot a_{i,2j}
	\end{equation}
	\begin{equation}
		MulV_j = \sum_{i=1}^{m/2} b_{2i-1,j} \cdot b_{2i,j}
	\end{equation}
	
	\item элементы результирующей матрицы вычисляются по формуле:
	\begin{equation}
		c_{ij} = -MulH_i - MulV_j + \sum_{k=1}^{m/2} (a_{i,2k-1} + b_{2k,j}) \cdot (a_{i,2k} + b_{2k-1,j})
	\end{equation}
	
	\item если $m$ нечётное, добавляется дополнительный член:
	\begin{equation}
		c_{ij} += a_{i,m} \cdot b_{m,j}
	\end{equation}
\end{enumerate}

Алгоритм Винограда сокращает количество операций умножения примерно в 2 раза по сравнению с классическим алгоритмом~\cite{winograd1968}.

\section{Оптимизированный алгоритм Винограда умножения матриц}

Оптимизированная версия алгоритма Винограда по условию лабораторной работы включает:

\begin{enumerate}
	\item предварительное вычисление значений ($N-1$, $N/2$ и др.);
	
	\item операцию умножения на 2 программно реализовывать как побитовый сдвиг влево на 1;
	
\end{enumerate}

Оптимизации позволяют дополнительно ускорить выполнение алгоритма за счёт уменьшения количества арифметических операций и оптимизации работы с памятью.

\section*{Вывод}

В аналитической части рассмотрены три алгоритма умножения матриц:
\begin{itemize}
	\item классический алгоритм -- базовый подход с временной сложностью $O(n^3)$;
	\item алгоритм Винограда -- оптимизация с предварительным вычислением вспомогательных векторов, сокращающая количество умножений;
	\item оптимизированный алгоритм Винограда -- улучшенная версия с битовыми операциями и кэшированием.
\end{itemize}

\clearpage