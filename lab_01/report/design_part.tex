\chapter{Конструкторская часть}

\section {Требования к реализации}

К программе предъявлены ряд функциональных требований: входные данные -- размеры матрицы, целые числа и матрица, двумерный массив целых чисел, выходные данные -- матрица.

К программе предъявлены ряд требований:

\begin{itemize}[label=---]
	\item наличие интерфейса для выбора действий;
	\item наличие стандартной реализации матрицы с динамическим выделением памяти;
	\item наличие функциональности замера процессорного времени алгоритмов умножения матриц;
	\item реализация трёх алгоритмов умножения матриц: классического, Винограда и оптимизированного Винограда.
\end{itemize}

Программа работает в двух режимах: одиночное выполнение умножения введённых пользователем матриц, а также массированный замер времени выполнения реализаций алгоритмов умножения матриц.

При первом режиме на вход поступают две целочисленные матрицы, на выход -- результирующая матрица. Она пустая, если перемножение матриц невозможно из-за их размеров.

При втором режиме работы на вход поступают начальный размер исходных матриц, конечный размер, шаг и число итераций, на выход -- результат замера времени в виде таблицы.

\section {Разработка алгоритмов}

Раздел содержит блок-схемы, описывающие следующие алгоритмы: классический алгоритм умножения матриц, алгоритм Винограда и оптимизированный алгоритм Винограда.

\begin{figure}[h!]\label{classic} 
	\center{\includegraphics[scale=0.5]{./images/classic.png}} 
	\caption{Схема классического алгоритма}
\end{figure}\clearpage

\begin{figure}[h!]\label{vinograd_1} 
	\center{\includegraphics[scale=0.5]{./images/vinograd_1.png}} 
	\caption{Схема алгоритма Винограда (часть 1)}
\end{figure}\clearpage

\begin{figure}[h!]\label{vinograd_2} 
	\center{\includegraphics[scale=0.55]{./images/vinograd_2.png}} 
	\caption{Схема алгоритма Винограда (часть 2)}
\end{figure}\clearpage

\begin{figure}[h!]\label{opt_vinograd_1} 
	\center{\includegraphics[scale=0.55]{./images/opt_vinograd_1.png}} 
	\caption{Схема оптимизированного алгоритма Винограда (часть 1)}
\end{figure}\clearpage

\begin{figure}[h!]\label{opt_vinograd_2} 
	\center{\includegraphics[scale=0.55]{./images/opt_vinograd_2.png}} 
	\caption{Схема оптимизированного алгоритма Винограда (часть 2)}
\end{figure}\clearpage

\begin{figure}[h!]\label{opt_vinograd_3} 
	\center{\includegraphics[scale=0.6]{./images/opt_vinograd_3.png}} 
	\caption{Схема оптимизированного алгоритма Винограда (часть 3)}
\end{figure}\clearpage

\section {Модель вычислений}
Для проведения оценки трудоёмкости была введена модель вычислений.

\begin{enumerate} 
	\item[1) ] трудоёмкость базовых операций:
	\begin{itemize} 
		\item равна 1 для: =, !=, ==, <, >, <=, >=, |, ||, \&, \&\&, |=, \&=, +, ++,  -, --,  +=, -=, [], $<<$, $>>$
		\item равна 2 для: *, /, *=, /=, \%, \%=
	\end{itemize}
	\item[2) ] трудоёмкость условного оператора:
	\[
	f_{if} = f_{\text{условия}} + 
	\begin{cases}
		min(f_1, f_2), & \text{л. с.}\\
		max(f_1, f_2), & \text{х. с.}
	\end{cases}
	\]
	\item[3) ] трудоёмкость цикла:
	\[
	f_{for} = f_{\text{инициализации}} + f_{\text{сравнения}} + M_{\text{итераций}} \cdot (f_{\text{тела}} + f_{\text{инкремента}} + f_{\text{сравнения}})
	\]
\end{enumerate}

\section {Трудоёмкость алгоритмов}

\subsection {Классический алгоритм}

Для классического алгоритма трудоёмкость будет складываться из:

\begin{itemize} 
	\item цикла по $i \in [0, N)$:
	\[
		f_{i} = 1 + 1 + N \cdot (f_{\text{тела}} + 1 + 1) = 2 + N \cdot (f_{\text{тела}} + 2)
	\]
	\item цикла по $j \in [0, M)$:
	\[
		f_{j} = 1 + 1 + M \cdot (f_{\text{тела}} + 1 + 1) = 2 + M \cdot (f_{\text{тела}} + 2)
	\]
	\item цикла по $k \in [0, P)$:
	\[
		f_{k} = 1 + 1 + P \cdot (f_{\text{тела}} + 1 + 1) = 2 + P \cdot (f_{\text{тела}} + 2)
	\]
	\item операции умножения и сложения элементов:
	\[
		f_{mult} = 8 + 2 + 2 = 12
	\]
\end{itemize}

Таким образом:

\[
	f_{standard} = 2 + N \cdot (2 + M \cdot (2 + P \cdot (12 + 2) + 2) + 2) = 14NMP + 4NM + 4N + 2 \approx 14NMP = O(N^3)
\]

где $N$ --- количество строк первой матрицы, $M$ --- количество столбцов второй матрицы, $P$ --- количество столбцов первой матрицы.

\subsection {Алгоритм Винограда}

Для алгоритма Винограда трудоёмкость будет складываться из:

\begin{itemize} 
	\item расчёта MulH:
	\[
		f_{MulH} = 2 + N \cdot (4 + M/2 \cdot ((6 + 3 + 6) + 4) + 2) = 9.5NM + 6N + 2
	\]
	\item расчёта MulV:
	\[
		f_{MulV} = 2 + P \cdot (4 + M/2 \cdot ((6 + 3 + 6) + 4) + 2) = 9.5PM + 6P + 2
	\]
	\item расчёта элементов результирующей матрицы C:
	\[
		f_{c} = 2 + N \cdot (2 + P \cdot (4 + M/2 \cdot (12 + 6 + 10 + 4) + 2 + 7) + 2) = 16NPM + 13NP + 4N + 2
	\]
	\item проверки размера на нечётность:
	\[
		f_{odd} = 3 + 
		\begin{cases}
			0, & \text{л. с.}\\
			2 + N \cdot (2 + P \cdot (8 + 4 + 2 + 2) + 2), & \text{х. с.}
		\end{cases}
		= 3 + 
		\begin{cases}
			0, & \text{л. с.}\\
			16NP + 4N + 2, & \text{х. с.}
		\end{cases}
	\]
\end{itemize}

Таким образом:

\[
	f_{winograd} = 9.5NM + 6N + 2 + 9.5PM + 6P + 2 + 16NPM + 13NP + 4N + 2 + f_{odd}  
\]

\[
	f_{winograd} = 16NPM + 13NP + 9.5NM +9.5PM + 10N + 6P + 9 +
	\begin{cases}
		0, & \text{л. с.}\\
		16NP + 4N + 2, & \text{х. с.}
	\end{cases}
\]

где $N$ --- количество строк первой матрицы, $M$ --- количество столбцов первой матрицы, $P$ --- количество столбцов второй матрицы.

Для лучшего случая (чётный размер матриц) имеем:
\[
	f_{best} = 16NPM + 13NP + 9.5NM + 9.5PM + 10N + 6P + 9 \approx 16NPM = O(N^3)
\]

Для худшего случая (нечётный размер матриц) имеем:
\[
	f_{worst} = 16NPM + 13NP + 9.5NM + 9.5PM + 10N + 6P + 9 + 16NP + 4N + 2 \approx 16NPM = O(N^3)
\]


\subsection {Оптимизированный алгоритм Винограда}

Для оптимизированного алгоритма Винограда трудоёмкость будет складываться из:

\begin{itemize} 
	\item предварительного вычисления констант:
	\[
		f_{const} = 2 + 2
	\]
	\item расчёта MulH (с использованием битовых операций):
	\[
		f_{MulH} = 2 + N \cdot (2 + M/2 \cdot (5 + 4 + 2 + 2) + 2) = 6.5MN + 4N + 2
	\]
	\item расчёта MulV (с использованием битовых операций):
	\[
		f_{MulV} = 2 + P \cdot (2 + M/2 \cdot (5 + 4 + 2 + 2) + 2) = 6.5MP + 4P + 2
	\]
	\item расчёта элементов результирующей матрицы C (с использованием битовых операций):
	\[
		f_{c} = 2 + N \cdot (2 + P \cdot (2 + M/2 \cdot (10 + 9 + 2 + 2) + 4 + 3 + 2) + 2) = 11.5 NPM + 11 PN + 4N + 2
	\]
	\item проверки размера на нечётность и обработки нечётного случая (с оптимизацией доступа к памяти):
	\[
		f_{odd} = 1 + 
		\begin{cases}
			0, & \text{л. с.}\\
			2 + N \cdot (3 + 2 + P \cdot (4 + 1 + 2 + 2) + 2), & \text{х. с.}
		\end{cases}
		= 1 + 
		\begin{cases}
			0, & \text{л. с.}\\
			9NP + 7N + 2, & \text{х. с.}
		\end{cases}
	\]
\end{itemize}

Таким образом:

\[
	f_{optimized\_winograd} =  2 + 2 + 6.5MN + 4N + 2 + 6.5MP + 4P + 2 + 11.5NMP + 11PN + 4N + 2 + f_{odd}  
\]

\[
	f_{optimized\_winograd} = 11.5NMP + 6.5MN + 6.5MP + 11PN + 4P + 8N + 11 +
	\begin{cases}
		0, & \text{л. с.}\\
		9NP + 7N + 2, & \text{х. с.}
	\end{cases}
\]

где $N$ --- количество строк первой матрицы, $M$ --- количество столбцов первой матрицы, $P$ --- количество столбцов второй матрицы.

Для лучшего случая (чётный размер матриц) имеем:
\[
	f_{best} = 11.5NMP + 6.5MN + 6.5MP + 20PN + 4P + 15N + 13 \approx 11.5NPM = O(N^3)
\]

Для худшего случая (нечётный размер матриц) имеем:
\[
	f_{worst} = 11.5NMP + 6.5MN + 6.5MP + 11PN + 4P + 8N + 11 \approx 16NPM = O(N^3)
\]

\section*{Вывод}

В данном разделе представлены блок-схемы и выполнена оценка трудоёмкости трёх алгоритмов умножения матриц: стандартного, Винограда и оптимизированного Винограда. Результаты расчётов, основанные на введённой модели вычислений, расположили алгоритмы по возрастанию вычислительной сложности следующим образом: оптимизированный Виноград, стандартный алгоритм, алгоритм Винограда.

\clearpage
